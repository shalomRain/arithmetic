<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // [9,4,2,10,7,8,8,1,9] 5
      // [4,8,12,16] 2
      // [100] 1
      //   var maxTurbulenceSize = function (arr) {
      //     let count = 1
      //     if (arr.length == 1) return count
      //     let afterNum = true
      //     let beforeNum = true
      //     let maxLength = 0
      //     for (let i = 1; i < arr.length; i++) {
      //       if (arr[i] > arr[i - 1] && beforeNum) {
      //         // 后面比前面大
      //         beforeNum = false
      //         afterNum = true
      //         count++
      //       } else if (arr[i] < arr[i - 1] && afterNum) {
      //         //   前面比后面大
      //         afterNum = false
      //         beforeNum = true
      //         count++
      //       } else if (arr[i] == arr[i - 1]) {
      //         // 相等时清除
      //         afterNum = true
      //         beforeNum = true
      //         count = 1
      //       } else {
      //         count = 2
      //       }
      //       maxLength = Math.max(maxLength, count)
      //     }
      //     return maxLength
      //   }

      //   *****************官方解答：双指针************************
      // 思路：获取两个坐标 left是起始坐标,right是结束的坐标,区间长度=right-left+1
      // 如果满足条件 right++，如果不满足条件,则left = right
      //   var maxTurbulenceSize = function (arr) {
      //     let maxLength = 0
      //     if (arr.length == 1) return 1
      //     let left = 0,
      //       right = 0
      //     while (right < arr.length - 1) {
      //       if (left == right) {
      //         if (arr[left] == arr[right]) {
      //           left++
      //         }
      //         right++
      //       } else {
      //         //   判断是否满足条件
      //         if (
      //           (arr[right - 1] > arr[right] && arr[right] < arr[right + 1]) ||
      //           (arr[right - 1] < arr[right] && arr[right] > arr[right + 1])
      //         ) {
      //           right++
      //         } else {
      //           left = right
      //         }
      //       }
      //       maxLength = Math.max(maxLength, right - left + 1)
      //     }
      //     return maxLength
      //   }

      // ******************************官方解答：动态规划******************************
      // 思路：用一个变量来进行替代，只要满足条件,变量则+1,当不满足条件时,则将其归为初始值
    //   var maxTurbulenceSize = function (arr) {
    //     if (arr.length == 1) return 1
    //     let maxLength = 0
    //     let p0 = 1
    //     let p1 = 1
    //     for (let i = 1; i < arr.length; i++) {
    //       if (arr[i - 1] < arr[i]) {
    //         p1 = p0 + 1
    //         p0 = 1
    //       } else if (arr[i - 1] > arr[i]) {
    //         p0 = p1 + 1
    //         p1 = 1
    //       } else {
    //         p1 = 1
    //         p0 = 1
    //       }
    //       maxLength = Math.max(maxLength, p0, p1)
    //     }
    //     return maxLength
    //   }

      console.log(maxTurbulenceSize([9, 4, 2, 10, 7, 8, 8, 1, 9]))
      console.log(maxTurbulenceSize([4, 8, 12, 16]))
      console.log(maxTurbulenceSize([100]))
      console.log(maxTurbulenceSize([1, 2, 4, 5, 9, 6, 10, 2, 4]))
      console.log(maxTurbulenceSize([9, 9]))
    </script>
  </body>
</html>
