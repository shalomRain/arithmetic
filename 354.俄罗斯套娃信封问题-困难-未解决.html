<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /**
       * @param {number[][]} envelopes
       * @return {number}
       */
      //   var maxEnvelopes = function (envelopes) {
      //     let methodOne = []
      //     let n = envelopes.length
      //     if (n <= 1) return n

      //     for (let i = 0; i < n; i++) {
      //       let value = envelopes[i][1]
      //       let arr = envelopes[i]
      //       let j = i - 1
      //       for (; j >= 0; --j) {
      //         if (envelopes[j][1] > value) {
      //           envelopes[j + 1] = envelopes[j]
      //         } else {
      //           break
      //         }
      //       }
      //       envelopes[j + 1] = arr
      //       // 先按envelops[i][0]进行排序,再按envelops[i][1]进行排序
      //     }

      //     for (let i = 0; i < n; i++) {
      //       let value = envelopes[i][0]
      //       let arr = envelopes[i]
      //       let j = i - 1
      //       for (; j >= 0; --j) {
      //         if (envelopes[j][0] > value) {
      //           envelopes[j + 1] = envelopes[j]
      //         } else {
      //           break
      //         }
      //       }
      //       envelopes[j + 1] = arr
      //       // 先按envelops[i][0]进行排序,再按envelops[i][1]进行排序
      //       //   console.log(envelopes)
      //     }
      //     methodOne = [...envelopes]
      //     console.log(methodOne)

      //     for (let i = 0; i < methodOne.length-1; i++) {
      //       // 当前的值比下一个值
      //       if (
      //         methodOne[i][0] < methodOne[i + 1][0] &&
      //         methodOne[i][1] < methodOne[i + 1][1]
      //       ) {
      //         //   啥也不做
      //       } else {
      //         methodOne.splice(i+1,1)
      //         i--
      //       }
      //     }
      //     console.log('处理methodOne',methodOne)

      //     let methodTwo = []
      //     for (let i = 0; i < n; i++) {
      //       let value = envelopes[i][1]
      //       let arr = envelopes[i]
      //       let j = i - 1
      //       for (; j >= 0; --j) {
      //         if (envelopes[j][1] > value) {
      //           envelopes[j + 1] = envelopes[j]
      //         } else {
      //           break
      //         }
      //       }
      //       envelopes[j + 1] = arr
      //       // 先按envelops[i][0]进行排序,再按envelops[i][1]进行排序
      //     }
      //     methodTwo = [...envelopes]
      //     console.log(methodTwo)

      //     for (let i = 0; i < methodTwo.length-1; i++) {
      //       // 当前的值比下一个值
      //       if (
      //         methodTwo[i][0] < methodTwo[i + 1][0] &&
      //         methodTwo[i][1] < methodTwo[i + 1][1]
      //       ) {
      //         //   啥也不做
      //       } else {
      //         methodTwo.splice(i+1,1)
      //         i--
      //       }
      //     }
      //     console.log('处理methodTwo',methodTwo)

      //     return methodOne.length>methodTwo.length?methodOne.length:methodTwo.length
      //   }

      let envelopes = [
        [2, 100],
        [3, 200],
        [4, 300],
        [1,2],
        [5, 400],
        [5, 450],
        [6, 470],
        [6, 360],
        [7, 380]
      ]

      //   let envelopes = [
      //     [46, 89],
      //     [50, 53],
      //     [52, 68],
      //     [72, 45],
      //     [77, 81]
      //   ] // 3
      // [46,89],[47,90],[48,91],[49,92],[50,53],[52,68],[77,81],[1,2]
      // var maxEnvelopes = function (envelopes) {
      //   if (envelopes.length <= 1) return envelopes.length
      //   let arr = [[envelopes[0]]] // [[[46,89],...,[arr[n][j]],[47,90]]]
      //   for (let i = 1; i < envelopes.length; i++) {
      //     // envelopes每个值去分组
      //     let value = envelopes[i]
      //     let index = 0
      //     let bol = true
      //     for (let n = 0; n < arr.length; n++) {
      //       // 分到arr[n]的组里面去比较，看是否有包含关系
      //       let j = arr[n].length - 1
      //       for (let j = 0; j < arr[n].length; j++) {
      //         // 比较里面的每一个值
      //         if (
      //           arr[n][j][0] < envelopes[i][0] &&
      //           arr[n][j][1] < envelopes[i][1]
      //         ) {
      //           index++
      //         } else if (
      //           arr[n][0][0] > envelopes[i][0] &&
      //           arr[n][0][1] > envelopes[i][1]
      //         ) {
      //         } else {
      //           bol = false
      //         }
      //       }
      //       if (index || bol) {
      //         arr[n].splice(index, 0, envelopes[i])
      //       } else {
      //         if (n == arr.length - 1) {
      //           arr.push([envelopes[i]])
      //           break
      //         }
      //       }
      //     }
      //   }
      //   console.log(arr)
      //   let returnLength = 0
      //   for(let i = 0;i<arr.length;i++){
      //       returnLength = Math.max(returnLength,arr[i].length)
      //   }
      //   console.log(returnLength)
      //   return returnLength
      // }
      // 不满足条件就创一个新的数组,满足条件就推入满足
      /*
      [ [ 46, 89 ], [ 50, 53 ], [ 52, 68 ], [ 72, 45 ], [ 77, 81 ] ]
      处理methodOne [ [ 46, 89 ] ]
      [ [ 72, 45 ], [ 50, 53 ], [ 52, 68 ], [ 77, 81 ], [ 46, 89 ] ]
      处理methodTwo [ [ 72, 45 ], [ 77, 81 ] ]
      */
      //   let envelopes = [
      //     [5, 4],
      //     [6, 4],
      //     [6, 7],
      //     [2, 3],
      //     [7, 4],
      //     [8, 5],
      //     [9,6]
      //   ]

      // *********************************官方解答一*****************************************************
      var maxEnvelopes = function (envelopes) {
        if (envelopes.length === 0) {
          return 0
        }

        const n = envelopes.length
        envelopes.sort((e1, e2) => {
          // 如果前面的一个数值不等于后面一个值,则以前面的值按从小到大排序
          if (e1[0] !== e2[0]) {
            return e1[0] - e2[0]
          } else {
            // 为什么这里是e2[1] - e1[1] 而不是e1[1] - e2[1]？
            // 因为后面采用累加计算，如果e1[1] - e1[1]=>[[5,100],[5,101]],那么会在累加,而实际上此时由于x轴上的数一样，不应该累加，故需要交换排序
            return e2[1] - e1[1]
          }
        })
        // 先将envelopes进行了排序

        const f = new Array(n).fill(1) // 信封宽度最少为1
        let ans = 1
        for (let i = 1; i < n; ++i) {
          for (let j = 0; j < i; ++j) {
            if (envelopes[j][1] < envelopes[i][1]) {
              // 后面的值如果比前面的值要大,f[i] = f[j] + 1 //f[j]可以看成保存的变量

              // 冒泡排序,总是重新排序，从第一个开始依次比较
              f[i] = Math.max(f[i], f[j] + 1)
            }
          }
          ans = Math.max(ans, f[i])
        }
        console.log(ans)
        return ans
      }

      maxEnvelopes(envelopes)
    </script>
  </body>
</html>
